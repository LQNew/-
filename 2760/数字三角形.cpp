/*给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。
  注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。
  输入：
  输入的是一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。
  输出：
  输出最大的和

  分析：
  7
  3 8
  8 1 0
  2 7 4 4
  4 5 2 6 5
  可以自底向上推，自最底层相邻较大的一端加上上一层的参数，形成又一层的最大值~
*/

#include<iostream>
using namespace std;
int main()
{
    int N;
    cin>>N;
    int Num[N][N];
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<i+1;j++)
            cin>>Num[i][j];//输入整个三角矩阵的数值
    }

    int MaxNum[N][N];
    for(int j=0;j<N;j++)
        MaxNum[N-1][j]=Num[N-1][j]; //先记录下最底层的最大路径数值
    for(int i=N-1;i>0;i--)
    {
        for(int j=0;j<i;j++)
        {
            if(MaxNum[i][j]<MaxNum[i][j+1]) //逆向向上寻找，因为路径必须找的是与当前结点相邻的左右结点，所以判别
                MaxNum[i-1][j]=MaxNum[i][j+1]+Num[i-1][j];
                //最终是每个结点都有自底向上赋予的当前计算出的最大值，关系点应是结点赋予数值的概念，而不应死抠在路径的概念上
            else
                MaxNum[i-1][j]=MaxNum[i][j]+Num[i-1][j];
        }
    }
    cout<<MaxNum[0][0];
    return 0;
}


