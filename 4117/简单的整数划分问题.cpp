/*
    描述
        将正整数n 表示成一系列正整数之和，n=n1+n2+…+nk, 其中n1>=n2>=…>=nk>=1 ，k>=1 。
        正整数n 的这种表示称为正整数n 的划分。正整数n 的不同的划分个数称为正整数n 的划分数。
    输入
        标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 < N <= 50)。
    输出
        对于每组测试数据，输出N的划分数。
    i.e: 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1 有七种组合
*/
//本道题思路不好想，还是蛮有技巧的一道题！！
//分析：当 m = 1 时，不论k的值为多少（k > 0 )，只有一种划分即 { 1 };
//当 n = 1 时，不论m的值为多少，只有一种划分即 m 个 1，{ 1, 1, 1, ..., 1 };
//当 m = n 时，根据划分中是否包含 n，可以分为两种情况：
//(a). 划分中包含n的情况，只有一个即 { n }；
//(b). 划分中不包含n的情况，这时划分中最大的数字也一定比 n 小，即 n 的所有 ( n - 1 ) 划分。因此 f(m, n) = 1 + f(n, n-1);
//当 m < n 时，由于划分中不可能出现负数，因此就相当于 f(m, m);
//当 m > n 时，根据划分中是否包含最大值 n，可以分为两种情况：
//(a)划分中包含 n的情况，划分个数为 f(m-n,n);
//(b). 划分中不包含 n 的情况，则划分个数为 f(m,n - 1);因此 f(m, n) = f(m-n, n) + f(m, n - 1);
#include<iostream>
using namespace std;
int N;

int cnt(int m,int n)
{
    if(m==1||n==1)
        return 1;
    else if(m==n)
        return cnt(m,n-1)+1; //m=n时，含n组成的种数为1，故cnt(m,n-1)+cnt(m-n,n)-->cnt(m,n-1)+1
    else if(m<n)
        return cnt(m,m);
    else
        return cnt(m,n-1)+cnt(m-n,n); //由1~n-1这些数组成 或 明确有n组成
}

int main()
{
    while(cin>>N)
        cout<<cnt(N,N)<<endl;
}
