/*填词游戏包括一个N * M大小的矩形方格盘和P个单词。玩家需要把每个方格中填上一个字母使得每个单词都能在方格盘上找到。每个单词都能找到要满足下面的条件：
  每个方格都不能同时属于超过一个的单词。一个长为k的单词一定要占据k个方格。单词在方格盘中出现的方向只能是竖直的或者水平的。
  你的任务是首先在方格盘上找到所有的单词，当然在棋盘上可能有些方格没有被单词占据。然后把这些没有用的方格找出来，把这些方格上的字母按照字典序组成一个“神秘单词”。
  输入：
  输入的第一行包括三个整数N，M和P (2 <= M, N <= 10, 0 <= P <=100)。接下来的N行，每行包括M个字符，来表示方格盘。接下来P行给出需要在方格盘中找到的单词。
  输入保证填词游戏至少有一组答案。（前提条件，解法就利用了这个前提条件）
  输入中给出的字母都是大写字母。
  输出:
  输出“神秘单词”，注意“神秘单词”中的字母要按照字典序给出。

  此道题看起来比较复杂，但是真正做起来难度不大，其实就是相当于把N*M中所有该找的字母给划去后，剩余的方格内的字母按照字典序输出...
  */
  #include<iostream>
  using namespace std;
  int main()
  {
      int letter[26]={0};
      int N,M,P;
      cin>>N>>M>>P;
      for(int i=0;i<N;i++) //读取值，也就是往N*M矩阵中填入值
      {
          char str[11];
          cin>>str;
          for(int j=0;j<M;j++)
            letter[str[j]-'A']++;
      }
      for(int i=0;i<P;i++) //注意题目中暗示开的数组长度大小！！
      {
          char str_1[102]; //删除矩阵中的字母
          cin>>str_1;
          for(int j=0;str_1[j]!='\0';j++)
            letter[str_1[j]-'A']--;
      }
      for(int i=0;i<26;i++)
      {
          while(letter[i]) //对矩阵中剩余字母进行统计并输出
          {
              cout<<char(i+'A'); //强制的数制转换：int->char
              letter[i]--;
          }
      }
      cout<<endl;
      return 0;
  }
