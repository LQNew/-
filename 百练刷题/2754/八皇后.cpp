/*
    描述
        会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！
        这就是著名的八皇后问题。 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。
        已经知道8皇后问题一共有92组解（即92个不同的皇后串）。给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。
    输入
        第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)
    输出
        输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。
*/
//分析：八皇后问题是著名的搜索问题，此道题的解法是借鉴网上的一则解法去做的：https://blog.csdn.net/u014082714/article/details/44901575
//将八皇后的问题转换为八叉树结构：我们每取出一个皇后，放入一行，共有八种不同的放法，然后再放第二个皇后，同样如果不考虑规则，还是有八种放法。
//于是我们可以用一个八叉树来描述这个过程。从根节点开始，树每增加一层，便是多放一个皇后，直到第8层（根节点为0层），最后得到一个完全八叉树。
//其实就是用DFS去搜索八叉树，其中需要加上约束条件，就是行、列　、斜线都没有别的皇后，转换为图的结构去考虑也就是：
//abs(i-k)==abs(place[i]-place[k])||place[i]==place[k] 代表的是同列及同斜线出现别的皇后
//接下来就是深搜，从根节点开始，逐层赋值元素，对应于八皇后每行选取列值，然后如果每次放置的皇后满足约束条件，那么进入下一层的搜索，回溯条件即为约束条件不满足时
//返回当前到达的树层，继续到另一个分叉去搜索；当搜索至最后一层后，将这一满足条件记录下来~
#include<iostream>
#include<cmath>
using namespace std;
int place[9]; //记录每次八皇后的存放位置
int strategies[93][9]; //记录成功的八皇后位置
int sum; //八皇后的解法数目
int n;
int b;

bool check(int k) //约束条件
{
    for(int i=1;i<k;i++) //判别当前树层之前所有层是否行、列、斜线均不存在其他八皇后
    {
        if(abs(i-k)==abs(place[i]-place[k])||place[i]==place[k])
            return false;
    }
    return true;
}

void Dfs(int level)
{
    if(level>8) //搜索到最底层后，此为一个成立的条件，用数组存储下来~
    {
        sum++;
        for(int i=1;i<=8;i++)
        {
            strategies[sum][i]=place[i];
        }
    }
    else
    {
        for(int col=1;col<=8;col++) //DFS搜索的递归式，理解思想！！
        {
            place[level]=col;
            if(check(level))
                Dfs(level+1);
        }
    }
}

int main()
{
    sum=0;
    Dfs(1); //从树的第一层开始搜索
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>b;
        for(int j=1;j<=8;j++)
            cout<<strategies[b][j];
        cout<<endl;
    }
    return 0;
}
